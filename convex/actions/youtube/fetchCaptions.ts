"use node";

/**
 * Fetch YouTube Video Captions/Transcript
 *
 * Fetches actual transcript text from YouTube videos using the innertube API.
 * This extracts the spoken content which contains the actual recipe instructions.
 */

import { v } from "convex/values";
import { action } from "../../_generated/server";
import { isValidVideoId } from "../../lib/youtubeUrlParser";

/**
 * Transcript segment from YouTube
 */
interface TranscriptSegment {
  text: string;
  start: number;
  duration: number;
}

/**
 * Extract transcript URL from YouTube page data
 */
function extractTranscriptUrl(html: string): string | null {
  // Look for caption tracks in the player response
  const patterns = [
    /"captionTracks":\s*\[(.*?)\]/s,
    /"playerCaptionsTracklistRenderer".*?"captionTracks":\s*\[(.*?)\]/s,
  ];

  for (const pattern of patterns) {
    const match = html.match(pattern);
    if (match && match[1]) {
      try {
        // Try to extract the baseUrl from caption tracks
        const urlMatch = match[1].match(/"baseUrl":\s*"([^"]+)"/);
        if (urlMatch && urlMatch[1]) {
          // Unescape the URL
          return urlMatch[1].replace(/\\u0026/g, "&").replace(/\\\//g, "/");
        }
      } catch {
        continue;
      }
    }
  }

  return null;
}

/**
 * Parse transcript XML into text
 */
function parseTranscriptXml(xml: string): TranscriptSegment[] {
  const segments: TranscriptSegment[] = [];

  // Match <text start="X" dur="Y">content</text> patterns
  const textPattern = /<text[^>]*start="([\d.]+)"[^>]*dur="([\d.]+)"[^>]*>([\s\S]*?)<\/text>/g;

  let match;
  while ((match = textPattern.exec(xml)) !== null) {
    const start = parseFloat(match[1]);
    const duration = parseFloat(match[2]);
    // Decode HTML entities and clean up text
    let text = match[3]
      .replace(/&amp;/g, "&")
      .replace(/&lt;/g, "<")
      .replace(/&gt;/g, ">")
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&nbsp;/g, " ")
      .replace(/\n/g, " ")
      .trim();

    if (text) {
      segments.push({ text, start, duration });
    }
  }

  return segments;
}

/**
 * Fetch transcript for a YouTube video
 *
 * This fetches the actual spoken content from the video, which is essential
 * for extracting recipes since creators speak the ingredients and instructions.
 *
 * @param videoId - YouTube video ID
 * @returns Transcript text if available
 */
export const fetchCaptions = action({
  args: {
    videoId: v.string(),
  },
  handler: async (_, args): Promise<{
    success: boolean;
    captionsText: string | null;
    captionTracks: { language: string; name: string; isAutoGenerated: boolean }[];
    error: { type: string; message: string } | null;
  }> => {
    const { videoId } = args;

    // Validate video ID format
    if (!isValidVideoId(videoId)) {
      return {
        success: false,
        captionsText: null,
        captionTracks: [],
        error: {
          type: "INVALID_VIDEO_ID",
          message: "Invalid YouTube video ID format",
        },
      };
    }

    try {
      // Step 1: Fetch the YouTube video page to get transcript URL
      const videoPageUrl = `https://www.youtube.com/watch?v=${videoId}`;

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      const pageResponse = await fetch(videoPageUrl, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
          "Accept-Language": "en-US,en;q=0.9",
          Accept: "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!pageResponse.ok) {
        console.warn(`Failed to fetch YouTube page: ${pageResponse.status}`);
        return {
          success: true, // Transcript is optional
          captionsText: null,
          captionTracks: [],
          error: null,
        };
      }

      const html = await pageResponse.text();

      // Step 2: Extract transcript URL from page data
      const transcriptUrl = extractTranscriptUrl(html);

      if (!transcriptUrl) {
        console.log("No transcript URL found for video:", videoId);
        return {
          success: true,
          captionsText: null,
          captionTracks: [],
          error: null,
        };
      }

      // Step 3: Fetch the actual transcript
      const transcriptController = new AbortController();
      const transcriptTimeoutId = setTimeout(() => transcriptController.abort(), 30000);

      const transcriptResponse = await fetch(transcriptUrl, {
        method: "GET",
        headers: {
          "User-Agent":
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        },
        signal: transcriptController.signal,
      });

      clearTimeout(transcriptTimeoutId);

      if (!transcriptResponse.ok) {
        console.warn(`Failed to fetch transcript: ${transcriptResponse.status}`);
        return {
          success: true,
          captionsText: null,
          captionTracks: [],
          error: null,
        };
      }

      const transcriptXml = await transcriptResponse.text();

      // Step 4: Parse the transcript XML into text
      const segments = parseTranscriptXml(transcriptXml);

      if (segments.length === 0) {
        console.log("No transcript segments found");
        return {
          success: true,
          captionsText: null,
          captionTracks: [],
          error: null,
        };
      }

      // Combine segments into readable text
      // Group by natural pauses (segments with gaps > 2 seconds become new paragraphs)
      let transcriptText = "";
      let lastEnd = 0;

      for (const segment of segments) {
        const gap = segment.start - lastEnd;
        if (gap > 2 && transcriptText.length > 0) {
          transcriptText += "\n\n";
        } else if (transcriptText.length > 0) {
          transcriptText += " ";
        }
        transcriptText += segment.text;
        lastEnd = segment.start + segment.duration;
      }

      console.log(`Fetched transcript with ${segments.length} segments, ${transcriptText.length} chars`);

      return {
        success: true,
        captionsText: transcriptText.trim(),
        captionTracks: [{ language: "en", name: "English", isAutoGenerated: true }],
        error: null,
      };
    } catch (error) {
      // Handle timeout
      if (error instanceof Error && error.name === "AbortError") {
        return {
          success: true, // Transcript is optional
          captionsText: null,
          captionTracks: [],
          error: null,
        };
      }

      console.error("Error fetching transcript:", error);
      // Return success with no captions - captions are optional
      return {
        success: true,
        captionsText: null,
        captionTracks: [],
        error: null,
      };
    }
  },
});

/**
 * Alternative: Fetch transcript using YouTube's innertube API
 * This is a more reliable method that doesn't require parsing HTML
 */
export const fetchTranscriptText = action({
  args: {
    videoId: v.string(),
  },
  handler: async (_, args): Promise<{
    success: boolean;
    transcriptText: string | null;
    error: { type: string; message: string } | null;
  }> => {
    const { videoId } = args;

    if (!isValidVideoId(videoId)) {
      return {
        success: false,
        transcriptText: null,
        error: {
          type: "INVALID_VIDEO_ID",
          message: "Invalid YouTube video ID format",
        },
      };
    }

    try {
      // Use YouTube's innertube API to get transcript
      const innertubeUrl = "https://www.youtube.com/youtubei/v1/get_transcript";

      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000);

      const response = await fetch(innertubeUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "User-Agent":
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
        },
        body: JSON.stringify({
          context: {
            client: {
              clientName: "WEB",
              clientVersion: "2.20240101.00.00",
            },
          },
          params: Buffer.from(`\n\x0b${videoId}`).toString("base64"),
        }),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        return {
          success: true, // Transcript is optional
          transcriptText: null,
          error: null,
        };
      }

      const data = await response.json();

      // Extract transcript text from response
      const transcriptRenderer =
        data?.actions?.[0]?.updateEngagementPanelAction?.content?.transcriptRenderer;
      const cueGroups =
        transcriptRenderer?.content?.transcriptSearchPanelRenderer?.body?.transcriptSegmentListRenderer?.initialSegments ||
        transcriptRenderer?.body?.transcriptSegmentListRenderer?.initialSegments ||
        [];

      if (cueGroups.length === 0) {
        return {
          success: true,
          transcriptText: null,
          error: null,
        };
      }

      // Extract text from cue groups
      const textParts: string[] = [];
      for (const cue of cueGroups) {
        const text =
          cue?.transcriptSegmentRenderer?.snippet?.runs?.[0]?.text ||
          cue?.transcriptSectionHeaderRenderer?.sectionHeader?.runs?.[0]?.text;
        if (text) {
          textParts.push(text);
        }
      }

      const transcriptText = textParts.join(" ").trim();

      return {
        success: true,
        transcriptText: transcriptText || null,
        error: null,
      };
    } catch (error) {
      console.warn("Could not fetch transcript via innertube:", error);
      return {
        success: true,
        transcriptText: null,
        error: null,
      };
    }
  },
});
